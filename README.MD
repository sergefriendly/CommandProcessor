# CommandProcessor

**Поддержка токенизации, цветного вывода и автодополнения для embedded-систем и не только.**


**Мощный и легковесный процессор команд для встроенных систем (Embedded C++) с поддержкой токенизации, цветного вывода и автодополнения.**

Этот проект представляет собой шаблонный класс на C++ для обработки текстовых команд в интерфейсах командной строки (CLI). Он разработан с учетом работы на микроконтроллерах (AVR) и на ПК, поддерживает динамическую токенизацию, цветной вывод, обработку escape-последовательностей и поиск команд.

## Особенности

* **Кросс-платформенность:** Работает как на AVR (Arduino), так и на PC (Linux/Windows/MacOS).
* **Шаблонный дизайн:** Размеры буферов и индексов задаются на этапе компиляции для контроля потребления памяти.
* **Динамическая токенизация:** Гибкое разбиение входной строки на аргументы с различными режимами.
* **Цветной вывод:** Поддержка ANSI-цветов для удобства отладки и пользовательского интерфейса.
* **Система команд:** Простая регистрация и поиск команд с указанием количества ожидаемых аргументов.
* **Автодополнение:** Функция для показа похожих команд по подстроке.
* **Экранирование символов:** Встроенная обработка escape-последовательностей (\n, \t, \r и др.).

## Быстрый старт
### Пример 1. Базовая настройка на Arduino

```C++
#include "CommandProcessor.h"
#include "io.h"
#include "utils.h"

using utils::i; // char* to int
using utils::d; // char* to double

// Создаем экземпляр процессора (буфер 64 байта, индекс на 16 токенов)
CommandProcessor<64, 16> cli;

// Создаём простую функцию
void sayHello() {
  // cli[1] содержит первый аргумент
  io::println(io::YELLOW, "!!! ", cli[1], " !!!", io::NO);
}

// Создаём вспомогательную функцию по выислению квадратного корня методом Ньютона-Рафсона 
double NewtonRaphsonSqrt(double x, double initial_guess, double iterations, bool verbose = false) {
  // Метод Ньютона-Рафсона
  double result = initial_guess;
  for (int i = 0; i < iterations; ++i) {
    result = 0.5 * (result + x / result);
    if (verbose)
      io::cout << i << ": " << result << io::endl;
  }
  return result;
}

// Оборачиваем метод для подачи в массив комманд
void sqrt() {
  int result = NewtonRaphsonSqrt( d(cli[1]), d(cli[2]), i(cli[3]) );
  io::println(io::ORANGE, result, io::NO);
}

// Объявляем массив команд: {Имя, Функция-обработчик, Кол-во аргументов}
Command cmd[] = {
  {"say", say, 1},
  {"sqrt", sqrt, -1},
};

void setup() {
  io::init(115200);
  cli.setPrompt(">> ").showWelcome().setDebugMode(false);
  cli.setCommands(cmd);
}

void loop() {
  cli.readInput();
}
```

### Пример 2.
```C++
#include "CommandProcessor.h"
#include "io.h"
#include "utils.h"

using utils::d; // char* to double

CommandProcessor<64, 16> cli;

void half_sum() {
  double a = d(cli[1]);
  double b = d(cli[2]);
  double result = (a + b) / 2;
  io::println("The half-sum of ", a, " and ", b, " is ", io::BLUE, result, io::NO);
}

Command cmd[] = {
  {"hsum", half_sum, -1},
};

int main() {
  cli.run(cmd, false, ">>> "); // debugMode = false, prompt = ">>> "
  return 0;
}
```

### Логика отделения аргументов
В строке

```C++
{"cmd", cmd, -1},
```
"cmd"  — это имя (или псевдоним) к функции-обработчику, по которому к этой функции можно обращаться интерактивно;

cmd    — сама функция-обработчик;

-1     — ожидаемое количество аргументов ```expectedArgCount```.

В зависимости от ожидаемого количества аргументов на выходе получается разная интерпретация:

```text
"cmd arg1 arg2 arg3 arg4" → ["cmd", "arg1 arg2 arg3 arg4"] при expectedArgCount = 1 → отделяется ровно одно слово — название команды, всё остальное идёт одним аргументом.
"cmd arg1 arg2 arg3 arg4" → ["cmd", "arg1", "arg2 arg3 arg4"] при expectedArgCount = 2 → отделяется команда и первый аргумент, всё остальное идёт третьим аргументом.
"cmd arg1 arg2 arg3 arg4" → ["cmd", "arg1", "arg2", "arg3 arg4"] при expectedArgCount = 3 → отделяется команда и первый и второй аргументы, всё остальное идёт четвёртым аргументом.
И т.д.
"cmd arg1 arg2 arg3 arg4" → ["cmd arg1 arg2 arg3 arg4"] при expectedArgCount = 0 → не отделяется ничего, но команда идентифицируется, и вместе с аргументами подаётся как единое целое.
"cmd arg1 arg2 arg3 arg4" → ["cmd", "arg1", "arg2", "arg3", "arg4"] при expectedArgCount = -1 → отделяются все слова, первое слово — команда, все остальные — аргументы.
```

Для аргументов, которые подаются в комлексе, может быть использован специальный парсер, разработанный пользователем.

## Структура проекта
```text
.
├── CommandProcessor.h  # Основной класс процессора команд
├── index.h             # Класс для работы с индексами (статический/динамический буфер)
├── io.h                # Абстракция ввода/вывода с поддержкой цветов (ANSI)
├── internal.h          # Внутренние платформо-зависимые функции (AVR/PC)
├── utils.h             # Вспомогательные утилиты (строки, математика)
└── examples/           # Папка с примерами использования (рекомендуется создать)
```

